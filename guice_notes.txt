Injection is a process of injecting dependency into an object.
This "main" method introduces a fundamental concept of Guice: the Module. The Module is the basic unit of definition of bindings
(or wiring, as it’s known in Spring).Guice has adopted a code-first approach for dependency injection and management so
you won’t be dealing with a lot of XML out-of-the-box.

Dependency Injection is controlled by the Guice Bindings. Guice uses bindings to map object types to their actual implementations.
These bindings are defined a module. A module is a collection of bindings.
The Module is the core building block for an Injector which is Guice's object-graph builder. First step is to create an injector
and then we can use the injector to get the objects.

The dependency tree of Communication will be implicitly injected using a feature called just-in-time binding, provided
the classes have the default no-arg constructor. This has been a feature in Guice since inception and only available
in Spring since v4.3.
Binding is to Guice as wiring is to Spring. With bindings, you define how Guice is going to inject dependencies into a class.

>>>>>
Linked bindings
In Linked bindings, Guice maps a type to its implementation.
bind(SpellChecker.class).to(SpellCheckerImpl.class);
and than 
@Inject
public TextEditor(SpellChecker spellChecker) {
	....
}

In case we want to map a type with multiple implementations, we can create custom annotation as well.
@BindingAnnotation @Target({ FIELD, PARAMETER, METHOD }) @Retention(RUNTIME)
@interface WinWord {}
and than 
bind(SpellChecker.class).annotatedWith(WinWord.class).to(WinWordSpellCheckerImpl.class);
and than
@Inject
public TextEditor(@WinWord SpellChecker spellChecker) {
	.....
}

Guice provides another way also to map bindings without creating a custom annotation. It allows so using @Named annotation.
bind(SpellChecker.class).annotatedWith(Names.named("OpenOffice")).to(OpenOfficeWordSpellCheckerImpl.class);
and than
@Inject
public TextEditor(@Named("OpenOffice") SpellChecker spellChecker) {
   .....
}

>>>>>
Instance binding
Guice provides a way to create bindings with value objects or constants.
bind(String.class).annotatedWith(Names.named("JBDC")).toInstance("jdbc:mysql://localhost:5326/emp");
and than 
@Inject
public void connectDatabase(@Named("JBDC") String dbUrl) {
   //...
}

bind(SpellChecker.class).toInstance(new SpellCheckerWinWord());
This binding will provide an instance of the SpellCheckerWinWord class wherever a SpellChecker variable is declared.
In this case, however, the dependency tree of the class will not be automatically wired. You should limit the use
of this mode where there isn’t any heavy initialization or dependency injection necessary.
One should avoid using .toInstance with objects that are complicated to create, since it can slow down application startup.
You can use an @Provides method instead.

>>>>>
Provider methods binding
Guice provides a way to create bindings with complex objects using @provides annotated method.
This method is being part of Binding Module and provides the complex object to be mapped.
@Provides
public SpellChecker provideSpellChecker() {
   //.....
   return spellChecker;
}
and than 
@Inject
public TextEditor(SpellChecker spellChecker) {
	//....
}

bind(MessageService.class).annotatedWith(Email.class).to(EmailService.class);
is same as
@Provides
@Email
public MessageService provideMessageService() {
  return new EmailService();
}
 
>>>>>
Provider class binding
As @provides method becomes more complex, these methods can be moved to separate classes using Provider interface.
class SpellCheckerProvider implements Provider<SpellChecker> {
   @Override
   public SpellChecker get() {
      //......
      return SpellChecker;
   } 
}
and than 
bind(SpellChecker.class).toProvider(SpellCheckerProvider.class);
and than
@Inject
public TextEditor(SpellChecker spellChecker) {
	//....
}

Guice provides a way to create bindings with specific constructor of an object using toConstructor() method.
//Binding Module
@Override
protected void configure() {
   try {
      bind(SpellChecker.class)
         .toConstructor(SpellCheckerImpl.class.getConstructor(String.class));
   } catch (NoSuchMethodException | SecurityException e) {
      System.out.println("Required constructor missing");
   } 
   bind(String.class)
      .annotatedWith(Names.named("JDBC"))
      .toInstance("jdbc:mysql://localhost:5326/emp");
}
and than
public SpellCheckerImpl(@Named("JDBC") String dbUrl) {
   this.dbUrl = dbUrl;
}
and than
@Inject
public TextEditor( SpellChecker spellChecker) {
   this.spellChecker = spellChecker;
}

Guice will implicitly inject some general purpose components like the Injector and an instance of java.util.Logger,
among others. Guice provides inbuilt binding for java.util.logging.Logger class. Logger's name is automatically set
to the name of the class into which the Logger is injected.
@Inject
public TextEditor( Logger logger) {
   this.logger = logger;
}
and than, actually nathing since guice provides inbuild binding to Logger class

>>>>>
In other to create instance of the class, Guice will use @Inject annotated constructor. There can be one and only one
@Inject annotated constructor. if there is no @Inject annotated constructor, default empty constructor is used.

>>>>>
As bindings are defined in Binding Module, Guice uses them whenever it needs to inject dependencies. In case bindings are not
present, it can attempt to create just-in-time bindings. Bindings present in binding module are called explicit bindings
and are of higher precedence whereas just-in-time bindings are called implicit bindings. If both type of bindings are present,
explicit bindings are considered for mapping.

Non-private, No-argument constructors are eligible for just-in-time bindings. Another way is to annotate a constructor with
@Inject annotation.

>>>>>
@ImplementatedBy annotation tells the guice about the implementation class. No binding is required in Binding Module
in such a case.

>>>>>
@ProvidedBy annotation tells the guice about the provider of implementation class. No binding is required in Binding Module
in such a case.

>>>>>
Optional injection
Optional injection means injecting the dependency if exists. Method and Field injections may be optionally dependent and should have
some default value if dependency is not present.

   private String dbUrl = "jdbc:mysql://localhost:5326/emp";
   ...
   @Inject(optional=true)
   public void setDbUrl(@Named("JDBC") String dbUrl) {
      this.dbUrl = dbUrl;
   }
   
>>>>>
On-Demand Injection
Method and field injections can be used to initialize using exiting object using injector.injectMembers() method.

>>>>>
Guice returns a new instance every time when it supplies a value as its default behavior.
This is configurable via scopes. Following are the built in scopes that Guice supports :
@Singleton
@SessionScope
@RequestScope

Ways to apply scope:
At class level:
	@Singleton
	class SpellCheckerImpl implements SpellChecker {
		....
	}
At configuration level:
	bind(SpellChecker.class).to(SpellCheckerImpl.class).in(Singleton.class);
At Method level:
	@Provides @Singleton
	public SpellChecker provideSpellChecker() {
		....
		SpellChecker SpellChecker = new SpellCheckerImpl(dbUrl, user, timeout);
		return SpellChecker;
	}

>>>>>
Guice AOP
The functions that span multiple points of an application are called cross-cutting concerns and these cross-cutting concerns are
conceptually separate from the application's business logic.
Dependency Injection helps you decouple your application objects from each other and AOP helps you decouple cross-cutting concerns
from the objects that they affect.
Important Classes
	Matcher − Matcher is an interface to either accept or reject a value. In Guice AOP, we need two matchers: one to define which
				classes participate, and another for the methods of those classes.
	MethodInterceptor − MethodInterceptors are executed when a matching method is called. They can inspect the call: the method,
						its arguments, and the receiving instance. We can perform cross-cutting logic and then delegate to
						the underlying method. Finally, we may inspect the return value or exception and return.

